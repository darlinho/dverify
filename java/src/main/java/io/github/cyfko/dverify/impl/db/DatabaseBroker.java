package io.github.cyfko.dverify.impl.db;

import io.github.cyfko.dverify.Broker;
import io.github.cyfko.dverify.exceptions.DataExtractionException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.sql.DataSource;
import java.sql.*;
import java.util.concurrent.CompletableFuture;

/**
 * A {@link io.github.cyfko.dverify.Broker} implementation that stores and retrieves messages
 * using a relational SQL database. This broker is useful in distributed environments where
 * consistent message delivery and verification are required across microservices or service replicas.
 *
 * <p>This implementation supports:</p>
 * <ul>
 *     <li>Automatic creation of the broker table if it does not already exist</li>
 *     <li>Configurable table name, validated to prevent SQL injection</li>
 *     <li>Asynchronous message storage and retrieval using {@link java.util.concurrent.CompletableFuture}</li>
 *     <li>Compatibility with major relational databases (PostgreSQL, MySQL, SQL Server, H2)</li>
 * </ul>
 *
 * <h2>Usage</h2>
 *
 * <pre>{@code
 * DataSource dataSource = ...;
 * String tableName = "broker_messages";
 * DatabaseBroker broker = new DatabaseBroker(dataSource, tableName);
 * }</pre>
 *
 * <h2>Table Schema</h2>
 *
 * <pre>{@code
 * CREATE TABLE broker_messages (
 *   id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
 *   message_key VARCHAR(255) NOT NULL,
 *   message_value TEXT NOT NULL,
 *   created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
 * );
 * }</pre>
 *
 * <p>This broker is particularly well-suited to high-availability setups involving:</p>
 * <ul>
 *     <li>Clustered databases with automatic failover</li>
 *     <li>Sharded deployments using consistent hashing or range partitioning</li>
 *     <li>Single-node monoliths where persistence is required</li>
 * </ul>
 *
 * <p>Note: Message keys must be unique. If a key is reused, the insertion will fail with a primary key violation.</p>
 *
 * @author Frank KOSSI
 * @since 3.0.3
 */
public class DatabaseBroker implements Broker {
    private static final String COLUMN_KEY = "message_key";
    private static final String COLUMN_MESSAGE = "message_value";
    private static final Logger log = LoggerFactory.getLogger(DatabaseBroker.class);
    private final DataSource dataSource;
    private final String tableName;

    public DatabaseBroker(DataSource dataSource, String tableName) {
        if (!isValidTableName(tableName)) {
            throw new IllegalArgumentException(String.format("Invalid table name: [%s]. Should start with a letter and only contains letters, digits or underscore.", tableName));
        }
        this.dataSource = dataSource;
        this.tableName = tableName;
        createBrokerTableIfNotExists();
    }

    private boolean isValidTableName(String tableName) {
        // Allow only alphanumeric characters and underscores, and must start with a letter
        return tableName != null && tableName.matches("^[a-zA-Z][a-zA-Z0-9_]*$");
    }

    private void createBrokerTableIfNotExists() {
        try (Connection connection = dataSource.getConnection()) {
            DatabaseMetaData meta = connection.getMetaData();
            String dbProduct = meta.getDatabaseProductName().toLowerCase();

            String idDefinition;
            String createdAtDefinition;

            if (dbProduct.contains("postgresql") || dbProduct.contains("h2")) {
                idDefinition = "id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY";
                createdAtDefinition = "created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP";
            } else if (dbProduct.contains("mysql")) {
                idDefinition = "id BIGINT AUTO_INCREMENT PRIMARY KEY";
                createdAtDefinition = "created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP";
            } else if (dbProduct.contains("oracle")) {
                idDefinition = "id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY";
                createdAtDefinition = "created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP"; // Oracle 12c+
            } else if (dbProduct.contains("sql server")) {
                idDefinition = "id BIGINT IDENTITY(1,1) PRIMARY KEY";
                createdAtDefinition = "created_at DATETIME DEFAULT GETDATE()";
            } else {
                throw new UnsupportedOperationException("Unsupported DB: " + dbProduct);
            }

            String ddl = asDDL(dbProduct, idDefinition, createdAtDefinition);

            try (Statement stmt = connection.createStatement()) {
                stmt.execute(ddl);
            }
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    private String asDDL(String dbProduct, String idDefinition, String createdAtDefinition) {
        if (dbProduct.contains("sql server")) {
            return String.format("""
            IF NOT EXISTS (
                SELECT * FROM INFORMATION_SCHEMA.TABLES
                WHERE TABLE_NAME = '%s'
            )
            BEGIN
                CREATE TABLE %s (
                    %s,
                    %s VARCHAR(255) NOT NULL UNIQUE,
                    %s TEXT NOT NULL,
                    %s
                )
            END
            """, tableName, tableName, idDefinition, COLUMN_KEY, COLUMN_MESSAGE, createdAtDefinition);
        }

        return String.format("""
        CREATE TABLE IF NOT EXISTS %s (
            %s,
            %s VARCHAR(255) NOT NULL UNIQUE,
            %s TEXT NOT NULL,
            %s
        )
        """, tableName, idDefinition, COLUMN_KEY, COLUMN_MESSAGE, createdAtDefinition);
    }

    @Override
    public CompletableFuture<Void> send(String keyId, String message) {
        return CompletableFuture.runAsync(() -> {
            try (Connection conn = dataSource.getConnection()) {
                if (keyId == null || keyId.isBlank() || message == null) return;

                if (message.isBlank()) { // Delete the record with keyId
                    String sql = String.format(
                            "DELETE FROM %s WHERE %s = ?",
                            tableName, COLUMN_KEY
                    );

                    try (PreparedStatement stmt = conn.prepareStatement(sql)) {
                        stmt.setString(1, keyId);
                        stmt.executeUpdate();
                    }
                } else { // save a new records with that keyId
                    String sql = String.format(
                            "INSERT INTO %s (%s, %s) VALUES (?, ?)",
                            tableName, COLUMN_KEY, COLUMN_MESSAGE
                    );

                    try (PreparedStatement stmt = conn.prepareStatement(sql)) {
                        stmt.setString(1, keyId);
                        stmt.setString(2, message);
                        stmt.executeUpdate();
                    }
                }

            } catch (SQLException e) {
                throw new RuntimeException("Failed to store message in DB", e);
            }
        });
    }

    @Override
    public String get(String keyId) {
        try (Connection conn = dataSource.getConnection()) {
            String sql = String.format(
                    "SELECT %s FROM %s WHERE %s = ? ORDER BY created_at",
                    COLUMN_MESSAGE, tableName, COLUMN_KEY
            );

            try (PreparedStatement stmt = conn.prepareStatement(sql)) {
                stmt.setString(1, keyId);
                ResultSet rs = stmt.executeQuery();
                if (rs.next()) {
                    return rs.getString(COLUMN_MESSAGE);
                } else {
                    throw new DataExtractionException("Message not found for key: " + keyId);
                }
            }
        } catch (SQLException e) {
            log.error("{}", e.getMessage());
            throw new DataExtractionException("Failed to retrieve message from DB for key: " + keyId);
        }
    }
}
